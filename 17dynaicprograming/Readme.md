#### 动态规划

动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。
它可以非常显著地降低时间复杂度，提高代码的执行效率。不过，它也是出了名的难学。
它的主要学习难点跟递归类似，那就是，求解问题的过程不太符合人类常规的思维方式。
对于新手来说，要想入门确实不容易。不过，等你掌握了之后，你会发现，实际上并没有想象中那么难。

- 使用动态规划后性能对比
```
lq@192 17dynaicprograming % go test -bench=.
goos: darwin
goarch: amd64
pkg: github.com/lqhandsome/Alg/17dynaicprograming
cpu: Intel(R) Core(TM) i5-1038NG7 CPU @ 2.00GHz
BenchmarkBackpack-8              8252320               128.4 ns/op
BenchmarkBackpackPyn-8          525301923                2.373 ns/op
```
我们把每一层重复的状态（节点）合并，只记录不同的状态，
然后基于上一层的状态集合，来推导下一层的状态集合。

动态规划解决问题的思路。
我们把问题分解为多个阶段，每个阶段对应一个决策。
我们记录每一个阶段可达的状态集合（去掉重复的），
然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，
动态地往前推进。这也是动态规划这个名字的由来，

### 一个模型三个特征

- 一个模型
```
值的是动态规划适合解决的问题的模型：多阶段决策，并求最优解模型
```
- 三个特征
```
- 最优子结构
 问题的最优解包含子问题的最优解，或者说通过子问题的最优解，推导出问题的最优解
 
- 无后效性
 1.在推导后面阶段状态的时候，只关心前面阶段的状态值，不关心这个状态是如何推导的
 2.某阶段状态一旦确定，就不受之后阶段的决策影响
 
- 重复子问题
不同的决策序列，到达某个相同的阶段后，可能会产生重复的问题。
```


### 编辑距离问题
```
根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，
比较著名的有莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。
其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作

且，莱文斯坦距离和最长公共子串长度，从两个截然相反的角度，分析字符串的相似程度。
莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。
```


#### 回溯方法莱文斯坦问题
`回溯是一个递归处理的过程。如果 a[i]与 b[j]匹配，我们递归考察 a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：`
- 可以删除 a[i]，然后递归考察 a[i+1]和 b[j]；
- 可以删除 b[j]，然后递归考察 a[i]和 b[j+1]；
- 可以在 a[i]前面添加一个跟 b[j]相同的字符，然后递归考察 a[i]和 b[j+1];
- 可以在 b[j]前面添加一个跟 a[i]相同的字符，然后递归考察 a[i+1]和 b[j]；
- 可以将 a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]。我们将上面的
